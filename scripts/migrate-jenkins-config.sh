#!/bin/bash
# Jenkins to GitHub Actions Migration Script
# Extracts key values from Jenkinsfile-project-* files and generates a pipeline-config.yml

set -e

# --- Configuration & Setup ---

# Set project root: use first argument if provided, otherwise use current directory
if [ -n "$1" ]; then
    PROJECT_ROOT="$(cd "$1" && pwd)"
else
    PROJECT_ROOT="$(pwd)"
fi

OUTPUT_FILE="$PROJECT_ROOT/.github/pipeline-config.yml"

echo "ðŸ”„ Starting Jenkins to GitHub Actions migration for project: $PROJECT_ROOT"

# --- Helper Functions ---

# Extracts a value from a Jenkinsfile, with a warning for missing values
extract_value() {
    local file="$1"
    local key="$2"
    local default_value="${3:-}"
    local value

    value=$(grep -E "^\s*${key}\s*=" "$file" | sed -E "s/.*=\s*['\"]([^'\"]*)['\"]_*/\1/" || echo "")

    if [ -z "$value" ] && [ -n "$default_value" ]; then
        echo "âš ï¸  Warning: Key '$key' not found in $file. Using default: '$default_value'"
        value="$default_value"
    elif [ -z "$value" ]; then
        echo "âš ï¸  Warning: Key '$key' not found in $file. No default set."
    fi
    echo "$value"
}

# Detects which quality tools are configured in the project
detect_quality_tools() {
    local tools=()
    echo "ðŸ”Ž Detecting quality tools..." >&2
    [ -f "$PROJECT_ROOT/.php-cs-fixer.php" ] || [ -f "$PROJECT_ROOT/.php-cs-fixer.dist.php" ] && tools+=("php-cs-fixer")
    [ -f "$PROJECT_ROOT/phpstan.neon" ] || [ -f "$PROJECT_ROOT/phpstan.neon.dist" ] || [ -f "$PROJECT_ROOT/phpstan.dist.neon" ] && tools+=("phpstan")
    [ -f "$PROJECT_ROOT/rector.php" ] && tools+=("rector")
    [ -f "$PROJECT_ROOT/phpunit.xml" ] || [ -f "$PROJECT_ROOT/phpunit.xml.dist" ] && tools+=("phpunit")

    if [ ${#tools[@]} -gt 0 ]; then
        echo "   Found: ${tools[*]}" >&2
    else
        echo "   No standard quality tools detected." >&2
    fi

    # Return space-separated list for other functions to use
    echo "${tools[@]}"
}

# Generates YAML list of enabled tools
generate_tools_yaml() {
    for tool in "$@"; do
        echo "    - \"$tool\""
    done
    echo "    - \"composer-validate\""
}

# Detects non-standard tool binary paths
detect_tool_binaries() {
    local detected_tools=($1)
    local binaries_config=""
    local custom_path_found=false

    echo "ðŸ”Ž Checking for custom tool binary paths..." >&2

    for tool in "${detected_tools[@]}"; do
        local default_bin="$PROJECT_ROOT/vendor/bin/$tool"
        local custom_bin_path="vendor/meteor/shop6-project-conventions/tools"
        local custom_bin="$PROJECT_ROOT/$custom_bin_path/$tool"

        if [ ! -f "$default_bin" ] && [ -f "$custom_bin" ]; then
            if [ "$custom_path_found" = false ]; then
                binaries_config+="  tool_binaries:\n"
                custom_path_found=true
            fi
            echo "   Found custom path for '$tool': './$custom_bin_path/$tool'" >&2
            binaries_config+="    $tool: \"./$custom_bin_path/$tool\"\n"
        fi
    done

    if [ "$custom_path_found" = false ]; then
        echo "   All tools are in standard vendor/bin path." >&2
    fi

    echo -e "$binaries_config"
}

# --- Main Logic ---

# 1. Find Jenkins configuration files
JENKINS_FILES=($(find "$PROJECT_ROOT" -name "Jenkinsfile-project-*" -type f))
if [ ${#JENKINS_FILES[@]} -eq 0 ]; then
    echo "âŒ No Jenkinsfile-project-* files found in $PROJECT_ROOT. Aborting."
    exit 1
fi
echo "âœ… Found ${#JENKINS_FILES[@]} Jenkins configuration file(s)."

# 2. Extract common settings from the first file found
FIRST_FILE="${JENKINS_FILES[0]}"
echo "ðŸ“„ Using '$FIRST_FILE' for common settings."

BUILD_NAME=$(extract_value "$FIRST_FILE" "BUILD_NAME")
CHAT_WEB_HOOK=$(extract_value "$FIRST_FILE" "CHAT_WEB_HOOK")
NODE_VERSION=$(extract_value "$FIRST_FILE" "NODE_VERSION" | cut -d. -f1)
PHP_RAW=$(extract_value "$FIRST_FILE" "PHP")
PHP_VERSION=$(echo "$PHP_RAW" | sed -E 's/php([0-9]+\.[0-9]+).*/\1/')
SYSTEM=$(extract_value "$FIRST_FILE" "SYSTEM")

# 3. Normalize hosting provider name
case "${SYSTEM,,}" in
    "byte")         PROVIDER="byte" ;;
    "digitalocean") PROVIDER="generic" ;;
    "level27")      PROVIDER="level27" ;;
    "hipex")        PROVIDER="hipex" ;;
    "hostedpower")  PROVIDER="hostedpower" ;;
    *)              PROVIDER="generic" ;;
esac

# 4. Detect quality tools
DETECTED_TOOLS_LIST=$(detect_quality_tools)
ENABLED_TOOLS_YAML=$(generate_tools_yaml $DETECTED_TOOLS_LIST)
TOOL_BINARIES_CONFIG=$(detect_tool_binaries "$DETECTED_TOOLS_LIST")

# 5. Generate pipeline-config.yml
echo "ðŸ“ Generating pipeline configuration file at '$OUTPUT_FILE'..."
mkdir -p "$(dirname "$OUTPUT_FILE")"

cat > "$OUTPUT_FILE" << EOF
# Unified CI/CD Configuration
# Schema: https://raw.githubusercontent.com/meteor-digital/github-actions/main/schemas/pipeline-config.schema.json
# Generated by Jenkins migration script. Please review and adjust as needed.

project:
  name: "$BUILD_NAME"

runtime:
  php_version: "$PHP_VERSION"
  node_version: "$NODE_VERSION"

notifications:
  notification_webhook: "$CHAT_WEB_HOOK"

quality_checks:
  enabled_tools:
${ENABLED_TOOLS_YAML:-  # Default to empty list if no tools found
    []}
${TOOL_BINARIES_CONFIG}

build:
  exclude_patterns: |
    .git*
    node_modules/*
    tests/*
    *.md
    docker-compose*
    devenv*
    .editorconfig
    .envrc
    .vscode
    composer.lock
    flake.*
    symfony.lock
    package*.json
    phpunit.xml*
    psalm*
    rector.php
    .php-cs-fixer.php
    grumphp.yml
    phpunuhi.xml
    bitbucket-pipelines.yml
    .shopware-project.yml
    Jenkinsfile*
    patch/*
    scripts/*

  build_commands: []

  # artifacts:
  #   retention_days: 1

deployment:
  environments:
EOF

# 6. Add environment-specific configurations
for jenkins_file in "${JENKINS_FILES[@]}"; do
    env_name=$(basename "$jenkins_file" | sed 's/Jenkinsfile-project-//' | tr '[:upper:]' '[:lower:]')
    echo "   -> Processing '$env_name' environment..."

    PROJECT_HOST=$(extract_value "$jenkins_file" "PROJECT_HOST")
    RELEASE_ROOT=$(extract_value "$jenkins_file" "RELEASE_ROOT")
    SSH_USER=$(extract_value "$jenkins_file" "SSH_USER")

    cat >> "$OUTPUT_FILE" << EOF
    $env_name:
      host: "${PROJECT_HOST:-your-host.example.com}"
      path: "${RELEASE_ROOT:-/path/to/release}"
      ssh_user: "${SSH_USER:-deploy-user}"
EOF
done

# 7. Add hosting provider configuration
cat >> "$OUTPUT_FILE" << EOF

  hosting:
    provider: "$PROVIDER"
    php_service: "$PHP_RAW"
EOF

# --- Completion --- 
echo "âœ… Generated pipeline configuration: $OUTPUT_FILE"
echo ""
echo "ðŸŽ‰ Migration completed!"
echo "   Next steps:"
echo "   1. Review the generated '$OUTPUT_FILE' for accuracy."
echo "   2. Fill in any missing values (e.g., host, path)."
echo "   3. Commit the new configuration to your repository."
echo "   4. Test your GitHub Actions workflows."
